{
    
    "main":{
        "prefix": "main",
        "body":[
            "#include<bits/stdc++.h>"
            "#define rep(i,n) for(int i=0; i< (n); i++)"
            "using namespace std;"
            "typedef long long ll;"
            "typedef pair<int,int> P;"
            "const int mod = 998244353;"
            "const int inf = (1<<30);"
            "const ll INF = (1ull<<62);"
        ]
        
    },
    "LazySegmentTree": {
        "prefix": "LazySegmentTree",
        "body": [
            "template <typename T, typename E, typename F, typename G, typename H>",
            "struct LazySegmentTree {",
            " private:",
            "  int n{}, sz{}, height{};",
            "  vector<T> data;",
            "  vector<E> lazy;",
            "  const F f;",
            "  const G g;",
            "  const H h;",
            "  const T ti;",
            "  const E ei;",
            "",
            "  inline void update(int k) { data[k] = f(data[2 * k + 0], data[2 * k + 1]); }",
            "",
            "  inline void all_apply(int k, const E &x) {",
            "    data[k] = g(data[k], x);",
            "    if (k < sz) lazy[k] = h(lazy[k], x);",
            "  }",
            "",
            "  inline void propagate(int k) {",
            "    if (lazy[k] != ei) {",
            "      all_apply(2 * k + 0, lazy[k]);",
            "      all_apply(2 * k + 1, lazy[k]);",
            "      lazy[k] = ei;",
            "    }",
            "  }",
            "",
            " public:",
            "  LazySegmentTree() = default;",
            "",
            "  explicit LazySegmentTree(int n, const F f, const G g, const H h, const T &ti,",
            "                           const E &ei)",
            "      : n(n), f(f), g(g), h(h), ti(ti), ei(ei) {",
            "    sz = 1;",
            "    height = 0;",
            "    while (sz < n) sz <<= 1, height++;",
            "    data.assign(2 * sz, ti);",
            "    lazy.assign(2 * sz, ei);",
            "  }",
            "",
            "  explicit LazySegmentTree(const vector<T> &v, const F f, const G g, const H h,",
            "                           const T &ti, const E &ei)",
            "      : LazySegmentTree(v.size(), f, g, h, ti, ei) {",
            "    build(v);",
            "  }",
            "",
            "  void build(const vector<T> &v) {",
            "    assert(n == (int)v.size());",
            "    for (int k = 0; k < n; k++) data[k + sz] = v[k];",
            "    for (int k = sz - 1; k > 0; k--) update(k);",
            "  }",
            "",
            "  void set(int k, const T &x) {",
            "    k += sz;",
            "    for (int i = height; i > 0; i--) propagate(k >> i);",
            "    data[k] = x;",
            "    for (int i = 1; i <= height; i++) update(k >> i);",
            "  }",
            "",
            "  T get(int k) {",
            "    k += sz;",
            "    for (int i = height; i > 0; i--) propagate(k >> i);",
            "    return data[k];",
            "  }",
            "",
            "  T operator[](int k) { return get(k); }",
            "",
            "  T prod(int l, int r) {",
            "    if (l >= r) return ti;",
            "    l += sz;",
            "    r += sz;",
            "    for (int i = height; i > 0; i--) {",
            "      if (((l >> i) << i) != l) propagate(l >> i);",
            "      if (((r >> i) << i) != r) propagate((r - 1) >> i);",
            "    }",
            "    T L = ti, R = ti;",
            "    for (; l < r; l >>= 1, r >>= 1) {",
            "      if (l & 1) L = f(L, data[l++]);",
            "      if (r & 1) R = f(data[--r], R);",
            "    }",
            "    return f(L, R);",
            "  }",
            "",
            "  T all_prod() const { return data[1]; }",
            "",
            "  void apply(int k, const E &x) {",
            "    k += sz;",
            "    for (int i = height; i > 0; i--) propagate(k >> i);",
            "    data[k] = g(data[k], x);",
            "    for (int i = 1; i <= height; i++) update(k >> i);",
            "  }",
            "",
            "  void apply(int l, int r, const E &x) {",
            "    if (l >= r) return;",
            "    l += sz;",
            "    r += sz;",
            "    for (int i = height; i > 0; i--) {",
            "      if (((l >> i) << i) != l) propagate(l >> i);",
            "      if (((r >> i) << i) != r) propagate((r - 1) >> i);",
            "    }",
            "    {",
            "      int l2 = l, r2 = r;",
            "      for (; l < r; l >>= 1, r >>= 1) {",
            "        if (l & 1) all_apply(l++, x);",
            "        if (r & 1) all_apply(--r, x);",
            "      }",
            "      l = l2, r = r2;",
            "    }",
            "    for (int i = 1; i <= height; i++) {",
            "      if (((l >> i) << i) != l) update(l >> i);",
            "      if (((r >> i) << i) != r) update((r - 1) >> i);",
            "    }",
            "  }",
            "",
            "  template <typename C>",
            "  int find_first(int l, const C &check) {",
            "    if (l >= n) return n;",
            "    l += sz;",
            "    for (int i = height; i > 0; i--) propagate(l >> i);",
            "    T sum = ti;",
            "    do {",
            "      while ((l & 1) == 0) l >>= 1;",
            "      if (check(f(sum, data[l]))) {",
            "        while (l < sz) {",
            "          propagate(l);",
            "          l <<= 1;",
            "          auto nxt = f(sum, data[l]);",
            "          if (not check(nxt)) {",
            "            sum = nxt;",
            "            l++;",
            "          }",
            "        }",
            "        return l + 1 - sz;",
            "      }",
            "      sum = f(sum, data[l++]);",
            "    } while ((l & -l) != l);",
            "    return n;",
            "  }",
            "",
            "  template <typename C>",
            "  int find_last(int r, const C &check) {",
            "    if (r <= 0) return -1;",
            "    r += sz;",
            "    for (int i = height; i > 0; i--) propagate((r - 1) >> i);",
            "    T sum = ti;",
            "    do {",
            "      r--;",
            "      while (r > 1 and (r & 1)) r >>= 1;",
            "      if (check(f(data[r], sum))) {",
            "        while (r < sz) {",
            "          propagate(r);",
            "          r = (r << 1) + 1;",
            "          auto nxt = f(data[r], sum);",
            "          if (not check(nxt)) {",
            "            sum = nxt;",
            "            r--;",
            "          }",
            "        }",
            "        return r - sz;",
            "      }",
            "      sum = f(data[r], sum);",
            "    } while ((r & -r) != r);",
            "    return -1;",
            "  }",
            "};",
            "",
            "template <typename T, typename E, typename F, typename G, typename H>",
            "LazySegmentTree<T, E, F, G, H> get_lazy_segment_tree(int N, const F &f,",
            "                                                     const G &g, const H &h,",
            "                                                     const T &ti, const E &ei) {",
            "  return LazySegmentTree{N, f, g, h, ti, ei};",
            "}",
            "",
            "template <typename T, typename E, typename F, typename G, typename H>",
            "LazySegmentTree<T, E, F, G, H> get_lazy_segment_tree(const vector<T> &v,",
            "                                                     const F &f, const G &g,",
            "                                                     const H &h, const T &ti,",
            "                                                     const E &ei) {",
            "  return LazySegmentTree{v, f, g, h, ti, ei};",
            "}",
        ],
        "description": ""
    }    "LazySegmentTree-exp": {
        "prefix": "LazySegmentTree-exp",
        "body": [
            "/*",
            "うしさんのライブラリのパクリ　すごくすごい",
            "f := ２つの区間をマージする演算",
            "auto F = [](const Node &a, const Node &b) { return a + b; };",
            "g := 作用素と要素をマージする２項演算",
            "auto G = [](const int &a, int x){ return a = x}",
            "h := 作用素同士をマージする",
            "auto h = [](int x,int y){return y}",
            "",
            "M1 := 要素の単位元　a*e = aとか",
            "OM0 := 作用素の単位元",
            "LazySegmentTree(n, f, g, h, M1, OM0):",
            "LazySegmentTree(v, f, g, h, M1, OM0):",
            " set(k, x): k 番目の要素を x に更新する.",
            "get(k): k 番目の要素を返す.",
            "operator[k]: k 番目の要素を返す.",
            "prod(l, r): 区間",
            "に対して二項演算した結果を返す.",
            "all_prod(): 全体を二項演算した結果を返す.",
            "apply(k, x): k 番目の要素に作用素 x を適用する.",
            "apply(l, r, x): 区間",
            "に対して作用素 x を適用する.",
            "find_first(a, check):",
            "が check を満たす最初の要素位置 を返す. 存在しないとき",
            "を返す.",
            "find_last(b, check):",
            "が check を満たす最後の要素位置 を返す. 存在しないとき を返す.",
            "*/",
        ],
        "description": ""
    },    "BIT": {
        "prefix": "BIT",
        "body": [
            "template <typename T>",
            "struct BinaryIndexedTree {",
            " private:",
            "  int n;",
            "  vector<T> data;",
            "",
            " public:",
            "  BinaryIndexedTree() = default;",
            "",
            "  explicit BinaryIndexedTree(int n) : n(n) { data.assign(n + 1, T()); }",
            "",
            "  explicit BinaryIndexedTree(const vector<T> &v)",
            "      : BinaryIndexedTree((int)v.size()) {",
            "    build(v);",
            "  }",
            "",
            "  void build(const vector<T> &v) {",
            "    assert(n == (int)v.size());",
            "    for (int i = 1; i <= n; i++) data[i] = v[i - 1];",
            "    for (int i = 1; i <= n; i++) {",
            "      int j = i + (i & -i);",
            "      if (j <= n) data[j] += data[i];",
            "    }",
            "  }",
            "",
            "  void apply(int k, const T &x) {",
            "    for (++k; k <= n; k += k & -k) data[k] += x;",
            "  }",
            "",
            "  T prod(int r) const {",
            "    T ret = T();",
            "    for (; r > 0; r -= r & -r) ret += data[r];",
            "    return ret;",
            "  }",
            "",
            "  T prod(int l, int r) const { return prod(r) - prod(l); }",
            "",
            "  int lower_bound(T x) const {",
            "    int i = 0;",
            "    for (int k = 1 << (__lg(n) + 1); k > 0; k >>= 1) {",
            "      if (i + k <= n && data[i + k] < x) {",
            "        x -= data[i + k];",
            "        i += k;",
            "      }",
            "    }",
            "    return i;",
            "  }",
            "",
            "  int upper_bound(T x) const {",
            "    int i = 0;",
            "    for (int k = 1 << (__lg(n) + 1); k > 0; k >>= 1) {",
            "      if (i + k <= n && data[i + k] <= x) {",
            "        x -= data[i + k];",
            "        i += k;",
            "      }",
            "    }",
            "    return i;",
            "  }",
            "};",
        ],
        "description": ""
    },
    "mint": {
        "prefix": "mint",
        "body": [
            "class mint {",
            "    long long x;",
            "public:",
            "    mint(long long x=0) : x((x%mod+mod)%mod) {}",
            "    mint operator-() const { ",
            "      return mint(-x);",
            "    }",
            "    mint& operator+=(const mint& a) {",
            "        if ((x += a.x) >= mod) x -= mod;",
            "        return *this;",
            "    }",
            "    mint& operator-=(const mint& a) {",
            "        if ((x += mod-a.x) >= mod) x -= mod;",
            "        return *this;",
            "    }",
            "    mint& operator*=(const  mint& a) {",
            "        (x *= a.x) %= mod;",
            "        return *this;",
            "    }",
            "    mint operator+(const mint& a) const {",
            "        mint res(*this);",
            "        return res+=a;",
            "    }",
            "    mint operator-(const mint& a) const {",
            "        mint res(*this);",
            "        return res-=a;",
            "    }",
            "    mint operator*(const mint& a) const {",
            "        mint res(*this);",
            "        return res*=a;",
            "    }",
            "    mint pow(ll t) const {",
            "        if (!t) return 1;",
            "        mint a = pow(t>>1);",
            "        a *= a;",
            "        if (t&1) a *= *this;",
            "        return a;",
            "    }",
            "    // for prime mod",
            "    mint inv() const {",
            "        return pow(mod-2);",
            "    }",
            "    mint& operator/=(const mint& a) {",
            "        return (*this) *= a.inv();",
            "    }",
            "    mint operator/(const mint& a) const {",
            "        mint res(*this);",
            "        return res/=a;",
            "    }",
            "",
            "    friend ostream& operator<<(ostream& os, const mint& m){",
            "        os << m.x;",
            "        return os;",
            "    }",
            "};",
        ],
        "description": ""
    },
    "DisjointSetUnion": {
        "prefix": "DisjointSetUnion",
        "body": [
            "class DisjointSetUnion {",
            "  int n;",
            "  vector<int> vals;",
            "",
            "  public:",
            "    DisjointSetUnion() = default;",
            "    explicit DisjointSetUnion(int n) : n(n), vals(n,-1){}",
            "",
            "",
            "    int leader(int v){",
            "      assert(v < n);",
            "      if(vals[v] < 0) return v;",
            "      return vals[v] = leader(vals[v]);",
            "    }",
            "",
            "    bool same(int u, int v){",
            "      assert(v < n);",
            "      assert(u < n);",
            "      return leader(u) == leader(v);",
            "    }",
            "",
            "",
            "    int merge(int u, int v){",
            "      assert(u < n);",
            "      assert(v < n);",
            "",
            "      int x = leader(u);",
            "      int y = leader(v);",
            "",
            "      if(x == y) return x;",
            "      if(-vals[x] < -vals[y]) swap(x,y);",
            "      vals[x] += vals[y];",
            "      vals[y] = x;",
            "      return x;",
            "    }",
            "    // === no need to implement from here ===",
            "",
            "",
            "    int group_size(int v){",
            "      assert(v < n);",
            "      return -vals[leader(v)];",
            "    }",
            "",
            "    vector<vector<int>> groups() {",
            "      vector<vector<int>> result(n);",
            "      vector<int> leaders(n), g_size(n);",
            "",
            "      for(int v = 0; v<n; v++){",
            "        leaders[v] = leader(v);",
            "        g_size[leaders[v]]++;",
            "      }",
            "      for(int v = 0; v < n; v++){",
            "        result[v].reserve(g_size[v]);",
            "      }",
            "      for(int v = 0; v  < n; v++){",
            "        result[leaders[v]].emplace_back(v);",
            "      }",
            "      auto empty_check = [](const vector<int> &vs){",
            "        return vs.empty();",
            "      };",
            "      result.erase(",
            "      remove_if(result.begin(), result.end(), empty_check),",
            "      result.end());",
            "",
            "      return result;",
            "    }",
            "};",
        ],
        "description": ""
    },   
     "WeightedUnionFInd": {
        "prefix": "WeightedUnionFInd",
        "body": [
            "template <typename T>",
            "struct WeightedUnionFind {",
            "  vector<int> data;",
            "  vector<T> ws;",
            "",
            "  WeightedUnionFind() {}",
            "",
            "  WeightedUnionFind(int sz) : data(sz, -1), ws(sz) {}",
            "",
            "  int find(int k) {",
            "    if (data[k] < 0) return k;",
            "    auto par = find(data[k]);",
            "    ws[k] += ws[data[k]];",
            "    return data[k] = par;",
            "  }",
            "",
            "  T weight(int t) {",
            "    find(t);",
            "    return ws[t];",
            "  }",
            "",
            "  bool unite(int x, int y, T w) {",
            "    w += weight(x);",
            "    w -= weight(y);",
            "    x = find(x), y = find(y);",
            "    if (x == y) return false;",
            "    if (data[x] > data[y]) {",
            "      swap(x, y);",
            "      w *= -1;",
            "    }",
            "    data[x] += data[y];",
            "    data[y] = x;",
            "    ws[y] = w;",
            "    return true;",
            "  }",
            "  bool same(int x,int y){",
            "    return find(x) == find(y);",
            "  }",
            "",
            "  T diff(int x, int y) { return weight(y) - weight(x); }",
            "};",
        ],
        "description": ""
    },
        "segmenttree": {
        "prefix": "segmenttree",
        "body": [
            "template <typename T, typename F>",
            "struct SegmentTree {",
            "  int n, sz;",
            "  vector<T> seg;",
            "",
            "  const F f;",
            "  const T ti;",
            "",
            "  SegmentTree() = default;",
            "",
            "  explicit SegmentTree(int n, const F f, const T &ti) : n(n), f(f), ti(ti) {",
            "    sz = 1;",
            "    while (sz < n) sz <<= 1;",
            "    seg.assign(2 * sz, ti);",
            "  }",
            "",
            "  explicit SegmentTree(const vector<T> &v, const F f, const T &ti)",
            "      : SegmentTree((int)v.size(), f, ti) {",
            "    build(v);",
            "  }",
            "",
            "  void build(const vector<T> &v) {",
            "    assert(n == (int)v.size());",
            "    for (int k = 0; k < n; k++) seg[k + sz] = v[k];",
            "    for (int k = sz - 1; k > 0; k--) {",
            "      seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);",
            "    }",
            "  }",
            "",
            "  void set(int k, const T &x) {",
            "    k += sz;",
            "    seg[k] = x;",
            "    while (k >>= 1) {",
            "      seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);",
            "    }",
            "  }",
            "",
            "  T get(int k) const { return seg[k + sz]; }",
            "",
            "  T operator[](const int &k) const { return get(k); }",
            "",
            "  void apply(int k, const T &x) {",
            "    k += sz;",
            "    seg[k] = f(seg[k], x);",
            "    while (k >>= 1) {",
            "      seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);",
            "    }",
            "  }",
            "",
            "  T prod(int l, int r) const {",
            "    T L = ti, R = ti;",
            "    for (l += sz, r += sz; l < r; l >>= 1, r >>= 1) {",
            "      if (l & 1) L = f(L, seg[l++]);",
            "      if (r & 1) R = f(seg[--r], R);",
            "    }",
            "    return f(L, R);",
            "  }",
            "",
            "  T all_prod() const { return seg[1]; }",
            "",
            "  template <typename C>",
            "  int find_first(int l, const C &check) const {",
            "    if (l >= n) return n;",
            "    l += sz;",
            "    T sum = ti;",
            "    do {",
            "      while ((l & 1) == 0) l >>= 1;",
            "      if (check(f(sum, seg[l]))) {",
            "        while (l < sz) {",
            "          l <<= 1;",
            "          auto nxt = f(sum, seg[l]);",
            "          if (not check(nxt)) {",
            "            sum = nxt;",
            "            l++;",
            "          }",
            "        }",
            "        return l + 1 - sz;",
            "      }",
            "      sum = f(sum, seg[l++]);",
            "    } while ((l & -l) != l);",
            "    return n;",
            "  }",
            "",
            "  template <typename C>",
            "  int find_last(int r, const C &check) const {",
            "    if (r <= 0) return -1;",
            "    r += sz;",
            "    T sum = ti;",
            "    do {",
            "      r--;",
            "      while (r > 1 and (r & 1)) r >>= 1;",
            "      if (check(f(seg[r], sum))) {",
            "        while (r < sz) {",
            "          r = (r << 1) + 1;",
            "          auto nxt = f(seg[r], sum);",
            "          if (not check(nxt)) {",
            "            sum = nxt;",
            "            r--;",
            "          }",
            "        }",
            "        return r - sz;",
            "      }",
            "      sum = f(seg[r], sum);",
            "    } while ((r & -r) != r);",
            "    return -1;",
            "  }",
            "};",
            "",
            "template <typename T, typename F>",
            "SegmentTree<T, F> get_segment_tree(int N, const F &f, const T &ti) {",
            "  return SegmentTree{N, f, ti};",
            "}",
            "",
            "template <typename T, typename F>",
            "SegmentTree<T, F> get_segment_tree(const vector<T> &v, const F &f,",
            "                                   const T &ti) {",
            "  return SegmentTree{v, f, ti};",
            "}",
        ],
        "description": ""
    },



}